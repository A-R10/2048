<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 Grid Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Prevents scrolling on touch devices */
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
            padding: 10px;
            background-color: #bbada0;
            border-radius: 6px;
            position: relative;
        }
        .grid-cell {
            width: 100%;
            padding-bottom: 100%; /* Creates a square aspect ratio */
            background-color: rgba(238, 228, 218, 0.35);
            border-radius: 3px;
        }
        .tile {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 3px;
            transition: all 0.15s ease-in-out;
            font-size: clamp(12px, 5vw, 28px);
        }
        /* Animation for new tiles */
        .tile-new {
            animation: appear 0.2s ease-in-out;
        }
        @keyframes appear {
            from {
                transform: scale(0);
            }
            to {
                transform: scale(1);
            }
        }
        /* Animation for merged tiles */
        .tile-merged {
            animation: pop 0.2s ease-in-out;
        }
        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl mx-auto">
        <!-- Header -->
        <header class="flex items-center justify-between mb-4">
            <h1 class="text-4xl md:text-5xl font-black text-gray-700">2048</h1>
            <div class="flex items-center space-x-2">
                <div class="bg-gray-700 text-white p-2 md:p-3 rounded-lg text-center">
                    <div class="text-xs font-bold uppercase text-gray-400">Score</div>
                    <div id="score" class="text-lg md:text-2xl font-bold">0</div>
                </div>
                <button id="new-game-btn" class="bg-orange-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-600 transition-colors">New Game</button>
            </div>
        </header>

        <!-- Game Board -->
        <main id="game-board" class="relative">
            <div id="grid-container" class="grid-container">
                <!-- Grid cells will be generated by JS -->
            </div>
            <div id="tile-container" class="absolute top-0 left-0 w-full h-full">
                <!-- Tiles will be generated by JS -->
            </div>
             <!-- Game Over / Win Overlay -->
            <div id="game-overlay" class="hidden absolute top-0 left-0 w-full h-full bg-white bg-opacity-75 rounded-lg flex-col items-center justify-center z-10">
                <h2 id="game-status-text" class="text-5xl font-black text-gray-800 mb-4">Game Over!</h2>
                <button id="try-again-btn" class="bg-orange-500 text-white font-bold py-3 px-6 rounded-lg hover:bg-orange-600 transition-colors text-xl">Try Again</button>
            </div>
        </main>
        
        <!-- Instructions -->
        <footer class="text-center mt-4 text-gray-500">
            <p>Use your <strong class="text-gray-700">arrow keys</strong> or <strong class="text-gray-700">swipe</strong> to move the tiles.</p>
            <p>Merge tiles of the same number to score points and reach the <strong class="text-gray-700">2048</strong> tile!</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gridContainer = document.getElementById('grid-container');
            const tileContainer = document.getElementById('tile-container');
            const scoreElement = document.getElementById('score');
            const newGameBtn = document.getElementById('new-game-btn');
            const tryAgainBtn = document.getElementById('try-again-btn');
            const gameOverlay = document.getElementById('game-overlay');
            const gameStatusText = document.getElementById('game-status-text');

            const GRID_WIDTH = 6;
            const GRID_HEIGHT = 4;
            const TOTAL_CELLS = GRID_WIDTH * GRID_HEIGHT;

            let grid = [];
            let score = 0;
            let isGameOver = false;

            // --- Game Setup ---

            function setupGame() {
                grid = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(0));
                score = 0;
                isGameOver = false;
                updateScore(0);
                gameOverlay.classList.add('hidden');
                gridContainer.innerHTML = '';
                tileContainer.innerHTML = '';

                for (let i = 0; i < TOTAL_CELLS; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    gridContainer.appendChild(cell);
                }

                addRandomTile();
                addRandomTile();
                drawGrid();
            }

            // --- Drawing and Rendering ---

            function drawGrid() {
                tileContainer.innerHTML = '';
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    for (let c = 0; c < GRID_WIDTH; c++) {
                        if (grid[r][c] !== 0) {
                            createTile(r, c, grid[r][c]);
                        }
                    }
                }
            }
            
            function createTile(row, col, value, isNew = false, isMerged = false) {
                const tile = document.createElement('div');
                tile.classList.add('tile');
                if (isNew) tile.classList.add('tile-new');
                if (isMerged) tile.classList.add('tile-merged');

                const { bg, text } = getTileColors(value);
                tile.style.backgroundColor = bg;
                tile.style.color = text;
                tile.textContent = value;
                
                const sizePercentage = 100 / GRID_WIDTH;
                const gap = 10;
                
                // Calculate position based on grid size and gaps
                const containerWidth = gridContainer.clientWidth;
                const containerHeight = gridContainer.clientHeight;
                const cellWidth = (containerWidth - (gap * (GRID_WIDTH + 1))) / GRID_WIDTH;
                const cellHeight = (containerHeight - (gap * (GRID_HEIGHT + 1))) / GRID_HEIGHT;
                
                tile.style.width = `${cellWidth}px`;
                tile.style.height = `${cellHeight}px`;
                tile.style.top = `${row * (cellHeight + gap) + gap}px`;
                tile.style.left = `${col * (cellWidth + gap) + gap}px`;
                
                tileContainer.appendChild(tile);
            }

            function getTileColors(value) {
                const colors = {
                    2: { bg: '#eee4da', text: '#776e65' },
                    4: { bg: '#ede0c8', text: '#776e65' },
                    8: { bg: '#f2b179', text: '#f9f6f2' },
                    16: { bg: '#f59563', text: '#f9f6f2' },
                    32: { bg: '#f67c5f', text: '#f9f6f2' },
                    64: { bg: '#f65e3b', text: '#f9f6f2' },
                    128: { bg: '#edcf72', text: '#f9f6f2' },
                    256: { bg: '#edcc61', text: '#f9f6f2' },
                    512: { bg: '#edc850', text: '#f9f6f2' },
                    1024: { bg: '#edc53f', text: '#f9f6f2' },
                    2048: { bg: '#edc22e', text: '#f9f6f2' },
                    'super': { bg: '#3c3a32', text: '#f9f6f2' }
                };
                return colors[value] || colors['super'];
            }
            
            function updateScore(points) {
                score += points;
                scoreElement.textContent = score;
            }

            // --- Game Logic ---

            function addRandomTile() {
                const emptyCells = [];
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    for (let c = 0; c < GRID_WIDTH; c++) {
                        if (grid[r][c] === 0) {
                            emptyCells.push({ r, c });
                        }
                    }
                }

                if (emptyCells.length > 0) {
                    const { r, c } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    const newValue = Math.random() < 0.9 ? 2 : 4;
                    grid[r][c] = newValue;
                    createTile(r, c, newValue, true); // Animate new tile
                }
            }

            function handleMove(e) {
                if (isGameOver) return;
                let moved = false;
                switch (e.key) {
                    case 'ArrowUp':
                        moved = moveUp();
                        break;
                    case 'ArrowDown':
                        moved = moveDown();
                        break;
                    case 'ArrowLeft':
                        moved = moveLeft();
                        break;
                    case 'ArrowRight':
                        moved = moveRight();
                        break;
                    default:
                        return;
                }
                
                if (moved) {
                    setTimeout(() => {
                        addRandomTile();
                        if (checkGameOver()) {
                            endGame(false);
                        }
                    }, 150);
                }
            }

            // Core move functions
            function moveLeft() {
                let moved = false;
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    const row = grid[r];
                    const originalRow = [...row];
                    const newRow = transformLine(row);
                    grid[r] = newRow;
                    if (JSON.stringify(originalRow) !== JSON.stringify(newRow)) {
                        moved = true;
                    }
                }
                if (moved) drawGridWithAnimations();
                return moved;
            }

            function moveRight() {
                let moved = false;
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    const row = grid[r].slice().reverse();
                    const originalRow = [...row];
                    const newRow = transformLine(row).reverse();
                    grid[r] = newRow;
                    if (JSON.stringify(originalRow.reverse()) !== JSON.stringify(newRow)) {
                        moved = true;
                    }
                }
                if (moved) drawGridWithAnimations();
                return moved;
            }

            function moveUp() {
                let moved = false;
                for (let c = 0; c < GRID_WIDTH; c++) {
                    const col = [];
                    for(let r = 0; r < GRID_HEIGHT; r++) col.push(grid[r][c]);
                    const originalCol = [...col];
                    const newCol = transformLine(col);
                    if (JSON.stringify(originalCol) !== JSON.stringify(newCol)) {
                        moved = true;
                    }
                    for(let r = 0; r < GRID_HEIGHT; r++) grid[r][c] = newCol[r];
                }
                if (moved) drawGridWithAnimations();
                return moved;
            }

            function moveDown() {
                let moved = false;
                for (let c = 0; c < GRID_WIDTH; c++) {
                    const col = [];
                    for(let r = 0; r < GRID_HEIGHT; r++) col.push(grid[r][c]);
                    const originalCol = [...col];
                    const newCol = transformLine(col.slice().reverse()).reverse();
                    if (JSON.stringify(originalCol) !== JSON.stringify(newCol)) {
                        moved = true;
                    }
                    for(let r = 0; r < GRID_HEIGHT; r++) grid[r][c] = newCol[r];
                }
                if (moved) drawGridWithAnimations();
                return moved;
            }

            function transformLine(line) {
                // 1. Slide: Remove zeros
                let filtered = line.filter(val => val !== 0);
                
                // 2. Combine
                for (let i = 0; i < filtered.length - 1; i++) {
                    if (filtered[i] === filtered[i+1]) {
                        filtered[i] *= 2;
                        updateScore(filtered[i]);
                        if (filtered[i] === 2048) endGame(true); // Win condition
                        filtered.splice(i + 1, 1);
                    }
                }
                
                // 3. Pad with zeros
                const result = Array(line.length).fill(0);
                filtered.forEach((val, i) => result[i] = val);
                return result;
            }
            
            // This function redraws the grid but adds animation hints
            function drawGridWithAnimations() {
                tileContainer.innerHTML = '';
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    for (let c = 0; c < GRID_WIDTH; c++) {
                        if (grid[r][c] !== 0) {
                            // Check if this tile was a result of a merge by looking for the same value nearby
                            // This is a simple heuristic and might not be perfect but works for visuals
                            const isMerged = false; // For simplicity, pop animation is on all moves now.
                                                     // A more complex state tracking is needed for perfect merge animation.
                            createTile(r, c, grid[r][c], false, true);
                        }
                    }
                }
            }


            // --- Game State Checks ---
            
            function checkGameOver() {
                // Check for empty cells
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    for (let c = 0; c < GRID_WIDTH; c++) {
                        if (grid[r][c] === 0) return false;
                    }
                }
                
                // Check for possible merges
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    for (let c = 0; c < GRID_WIDTH; c++) {
                        const val = grid[r][c];
                        // Check right
                        if (c < GRID_WIDTH - 1 && grid[r][c+1] === val) return false;
                        // Check down
                        if (r < GRID_HEIGHT - 1 && grid[r+1][c] === val) return false;
                    }
                }
                
                return true;
            }

            function endGame(isWin) {
                isGameOver = true;
                gameOverlay.classList.remove('hidden');
                gameOverlay.classList.add('flex');
                if (isWin) {
                    gameStatusText.textContent = 'You Win!';
                    // Allow continuing to play
                    tryAgainBtn.textContent = 'Keep Playing';
                    tryAgainBtn.onclick = () => {
                        isGameOver = false;
                        gameOverlay.classList.add('hidden');
                    };
                } else {
                    gameStatusText.textContent = 'Game Over!';
                    tryAgainBtn.textContent = 'Try Again';
                    tryAgainBtn.onclick = setupGame;
                }
            }

            // --- Event Listeners ---
            document.addEventListener('keydown', handleMove);
            newGameBtn.addEventListener('click', setupGame);
            tryAgainBtn.addEventListener('click', setupGame); // Default action

            // Touch controls
            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;

            gridContainer.addEventListener('touchstart', e => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            });

            gridContainer.addEventListener('touchend', e => {
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            });

            function handleSwipe() {
                if (isGameOver) return;
                const dx = touchEndX - touchStartX;
                const dy = touchEndY - touchStartY;
                const absDx = Math.abs(dx);
                const absDy = Math.abs(dy);

                if (Math.max(absDx, absDy) > 30) { // Threshold
                    let moved = false;
                    if (absDx > absDy) {
                        moved = dx > 0 ? moveRight() : moveLeft();
                    } else {
                        moved = dy > 0 ? moveDown() : moveUp();
                    }
                    if (moved) {
                        setTimeout(() => {
                           addRandomTile();
                           if (checkGameOver()) {
                               endGame(false);
                           }
                        }, 150);
                    }
                }
            }
            
            // Handle window resizing
            window.addEventListener('resize', drawGrid);

            // Initial game start
            setupGame();
        });
    </script>

</body>
</html>
